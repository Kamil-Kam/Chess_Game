For our final project, we decided to make a player versus computer implementation of chess using the pygame library for Python.
 It includes all the essential rules for chess. The computer player uses the minimax strategy with alpha-beta pruning for generating
 and deciding moves. It explores all possible moves, then explores their possible moves and so on. This essentially creates a search tree
 to a depth of 3. The best move is decided by evaluating the 'score' of the board. A graphical representation of the board is rendered with
 a side menu with contextual tips, that displays useful information such as whose turn it is, if the move you're attempting is invalid, if someone
 is in check, among other things. The mouse is used to select pieces and move them. The program only allows you to make valid moves according to the
 rules of chess, and also includes the special moves: castling, and promotion. The program automatically detects check and checkmate, and for the latter,
  ends the game and declares the winner.

For more specific instructions on how to play, see 'Usage Instructions'.

It's a simple chess game with a graphic interface. I created all the rules and engine myself; there are no imported versions.
This game allows us to play against the computer. There is still a lot to do, especially to improve and optimize the AI engine.

DONE:
Move ordering.
Some moves are likely to be better than others. Currently, the code considers move in the order: from the most promising.
As a result the search algorithm can potentially find the best move faster.

Game responsiveness.
The responsiveness is provided by using two processes during the game. One of them runs the main game functions, the other is responsible for the AI engine.

Chess rules:
All chess rules, and special moves are implemented.

Log panel with chess notation.

Pause and endgame statements.




TODO:
- improve get_valid_moves function to check only these moves which are possible invalid, now it`s iterating through all the moves

- use transposition tables: When the same position is encountered multiple times during the search, the program
can store the best move and score found so far in a hash table. This can speed up the search significantly, especially for deeper searches.

- implement chess openings book: the AI engine during the first few rounds can make moves due to an algorythm with most common chess openings.
It can make the AI faster, the AI engine may choose moves without time-consuming calculating

- implement iterative deepening: Instead of searching to a fixed depth, the program can perform multiple searches
 with increasing depths.

 - improve the evaluation function: The score_material() function only considers the material balance on the board.
 A better evaluation function would consider other factors such as piece mobility, king safety, pawn structure, and
 control of key squares.

- use multiprocessing in the AI engine: The search algorithm can be parallelized by searching different branches of the game tree concurrently.

- add main menu

- enable to choose by user, in which figure a pawn is promoted. Now it`s always the queen.

- add the threefold repetition rule