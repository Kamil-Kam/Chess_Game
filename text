
It's a simple chess game player vs computer with a graphic interface. I created all the rules and engine myself; there are no imported versions.
It includes almost all the essential rules for chess, except the threefold repetition rule. The computer player uses the negamax algorythm
with alpha-beta pruning for finding best moves. It explores all possible moves, then explores their possible moves and so on. Currently the depth
of searching is set on 3. The best move is decided by evaluating the score of the board. The graphical representation of the board is rendered 
with a log panel display, which displays chess notations all made moves. The mouse is used to select pieces and move them. The program only allows you
to make valid moves according to the rules of chess, and also includes the special moves: castling, en_passant and pawn promotion.
There is still a lot to do, especially to improve and optimize the AI engine.

DONE:
Move ordering.
Some moves are likely to be better than others. Currently, the code considers move in the order: from the most promising.
As a result the search algorithm can potentially find the best move faster.

Game responsiveness.
The responsiveness is provided by using two processes during the game. One of them runs the main game functions, the other is responsible for the AI engine.

Chess rules:
All chess rules, and special moves are implemented.

Log panel with chess notation.

Pause and endgame statements.




TODO:
- improve get_valid_moves function to check only these moves which are possible invalid, now it`s iterating through all the moves

- use transposition tables: When the same position is encountered multiple times during the search, the program
can store the best move and score found so far in a hash table. This can speed up the search significantly, especially for deeper searches.

- implement chess openings book: the AI engine during the first few rounds can make moves due to an algorythm with most common chess openings.
It can make the AI faster, the AI engine may choose moves without time-consuming calculating

- implement iterative deepening: Instead of searching to a fixed depth, the program can perform multiple searches
 with increasing depths.

 - improve the evaluation function: The score_material() function only considers the material balance on the board.
 A better evaluation function would consider other factors such as piece mobility, king safety, pawn structure, and
 control of key squares.

- use multiprocessing in the AI engine: The search algorithm can be parallelized by searching different branches of the game tree concurrently.

- add main menu

- enable to choose by user, in which figure a pawn is promoted. Now it`s always the queen.

- add the threefold repetition rule
